---
layout: post
title: Löve Gameloop
date: 2019-04-23
categories: lua
author: 4v0v
---


Créer un ficher ``main.lua``

```lua
function love.load()
end

function love.update(dt)
end

function love.draw()
end
```

+ ``love.load()``: appelé 1 fois à la lancé du programme
+ ``love.update(dt)``: appellé très rapidement 
+ ``dt``: le temps écoulé entre deux appels
+ ``love.draw()``: appellé très rapidement juste après love.update

```lua
function love.run()
	if love.load then love.load(love.arg.parseGameArguments(arg), arg) end
 
	-- We don't want the first frame's dt to include time taken by love.load.
	if love.timer then love.timer.step() end
 
	local dt = 0
 
	-- Main loop time.
	return function()
		-- Process events.
		if love.event then
			love.event.pump()
			for name, a,b,c,d,e,f in love.event.poll() do
				if name == "quit" then
					if not love.quit or not love.quit() then
						return a or 0
					end
				end
				love.handlers[name](a,b,c,d,e,f)
			end
		end
 
		-- Update dt, as we'll be passing it to update
		if love.timer then dt = love.timer.step() end
 
		-- Call update and draw
		if love.update then love.update(dt) end -- will pass 0 if love.timer is disabled
 
		if love.graphics and love.graphics.isActive() then
			love.graphics.origin()
			love.graphics.clear(love.graphics.getBackgroundColor())
 
			if love.draw then love.draw() end
 
			love.graphics.present()
		end
 
		if love.timer then love.timer.sleep(0.001) end
	end
end
```
---

On peut voir qu’il y a 3 parties dans ce code :

# Partie évènements :

```lua
love.event.pump()
for name, a,b,c,d,e,f in love.event.poll() do
	love.handlers[name](a,b,c,d,e,f)
end
```

Un évènement est une manipulation du joueur dans la fenêtre du jeu : click de souris, appuyer sur une touche, perte ou gain du focus de la fenêtre, redimention de la fenêtre ...
Chaque évènement est pris en charge par une fonction appelée ``callback``, c’est simplement une fonction qui s’exécute à la suite de la réalisation d’une action contrairement aux fonctions ``love.draw()`` et ``love.update()`` qui s’exécutent tout le temps.


A chaque fois qu’un évènement est créé, il est d’abord géré par le système d’exploitation puis transmis à la partie C++ de löve où il est stoké dans une pile d’évènements. ``love.event.pump()`` permet de récupérer cette pile et ``love.event.poll()`` de parcourir la pile précédement récupérée.
La raison pour laquelle on passe par une liste c’est qu’il est très fréquent que plusieurs évènements puissent se produire sur la même frame ou qu’ils durent moins d’une frame, ainsi en passant par le système d’exploitation on est sûre de ne pas en rater.

Dans la liste des fonctions callback, on peut remarquer qu’il y a au maximum 6 paramètres, ainsi on peut utiliser ``a,b,c,d,e,f`` comme paramètres à passer à ces fonctions.

Par exemple pour le callback ``love.keypressed(key, scancode, is_down)``:
+ ``a``: ``key``
+ ``b``: ``scancode``
+ ``c``: ``is_down``


# Partie update : 

```lua
if love.timer then dt = love.timer.step() end
if love.update then love.update(dt) end -- will pass 0 if love.timer is disabled
```

+ ``love.timer.step()``: récupère le temps d’exécution de la frame précédente puis l’injecter dans love.update.
La valeur dt est importante pour rendre l’exécution framerate independante, sinon la vitesse du jeu est dépendante de la puissance de l’ordinateur. On peut conprendre ce problème quand on voit des anciens jeux vidéos trouner sur des ordinateurs récents. Les jeux vont trop vite car la vitesse d’exécution de la boucle principale est très élevé comparé à l’époque .

Pour rendre une valeur framerate indépendante il suffi de la multiplier par dt.
On utilise souvant une valeur arbitraire représentant la vitesse pour se faire et ainsi faciliter les comparaisons entre vitesses.

Par exemple pour une machine qui va 2x plus vite qu’une autre.

```lua
Vitesse_x = 1000
Pos_x = 0

Love.update(dt)
Pos_x = pos_x +vitesse_x * dt	
end
```
La première machine va faire 2 boucles avec un dt de 0.5 tandis que la premiere fera 1 boucle avec un dt 2* plus important, les valeurs seront donc les mêmes.


# Draw :

```lua
if love.graphics and love.graphics.isActive() then
	love.graphics.origin()
	love.graphics.clear(love.graphics.getBackgroundColor())
 
	if love.draw then love.draw() end
 
	love.graphics.present()
end
```
 
+ ``love.graphics.origin()``: il est possible via des fonctions de faire tourner l’ensemble du contenu dessiné à l’écran d’un certain degré par exemple, cette fonction remet ce système de coordonné à zéro.
+ ``love.graphics.clear(love.graphics.getBackground())``: a chaque frame efface tout ce qui a été dessiné a la frame précédente avec la couleur de fond actuelle (configurable via ``love.graphics.setBackground())``.

+ ``love.graphics.present()``: permet d’afficher à l’écran tout ce qui a été dessiné via love.draw().

C’est intéressant de jouer avec les différentes fonctions de la boucle pour se familiariser avec, de voir par exemple qu’il est possible de dessiner dans la fonction love.update() en mettant love.graphics.present() dedans